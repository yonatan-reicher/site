<p>
The language I am most productive in is by far Elm. Elm is <em>awesome</em>.
There are a lot of reasons for that, no side effects, no runtime crashes, type
system is sound, code is simple and readable. All of these things are also (to
some degree) true for Haskell, for Rust, for lots of languages. It's also true
for Lean.
</p>
<p>
Well mostly true. Lean is a very complex language, made for proving
mathematical theorems, and for real world programming too (but mostly the nerdy
math stuff). If you have seen one of these you know how complex they can get.
Proof assistants use a bunch of magic and cool type theory to give you a super
complicated type system that is used to describe theorems. Then the proofs are
code that returns a value of the type of the theorem. This is like the dark
twin of Elm. Elm is simple and made for real world programming, just in it's
niche. Lean is complex and made not to even be run in real world applications.
</p>
<p>
Lean has a lot to learn from Elm (don't we all?). Elm simple design makes it
very productive to use and to debug when something goes wrong.
Lean on the other hand is super hard to understand how to use, it has multiple
passes of type checking and things called elaborations and abbreviations and
reductions and rewrites and type classes and it's really just a bunch of magic
thrown into one language. Sometimes you just don't have any idea how to do very
simple things when you are working with a type you don't know.
</p>
<p>
Currently I am researching ways to make Lean easier to use. So far a large part
of the effort has been to just learn all the features, then how each one works,
then how to use it.
</p>
<p>
WIP
</p>
